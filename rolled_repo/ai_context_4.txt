
===== FILE: src/app/admin/AdminDashboard/SettingsTabEnhanced.tsx =====
"use client";
import React, { useState, useRef, useEffect } from "react";
import {
RefreshCw,
Database,
Link as LinkIcon,
Calendar,
MessageSquare,
Navigation,
User,
Upload,
Save,
Trash2,
FileText,
type LucideIcon,
} from "lucide-react";
import { useMutation, useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useUploadThing } from "@/utils/uploadthing";
import { useToast } from "../hooks/useToast";
import { ToastContainer } from "../components/ToastContainer";
import Image from "next/image";
interface DataSource {
id: string;
label: string;
icon: LucideIcon;
description: string;
}
interface LogEntry {
timestamp: Date;
message: string;
type: "info" | "success" | "error";
}
interface MenuItem {
id: string;
label: string;
icon: LucideIcon;
}
const menuItems: MenuItem[] = [
{ id: "profile", label: "Profile", icon: User },
{ id: "data-management", label: "Data Management", icon: Database },
];
const SettingsTabEnhanced = () => {
const profile = useQuery(api.siteSettings.getProfile);
const updateProfile = useMutation(api.siteSettings.updateProfile);
const updateAvatar = useMutation(api.siteSettings.updateAvatar);
const removeAvatarMutation = useMutation(api.siteSettings.removeAvatar);
const [profileData, setProfileData] = useState({
name: "",
bio: "",
avatar: "",
email: "",
location: "",
});
const [isUploadingAvatar, setIsUploadingAvatar] = useState(false);
const [isSavingProfile, setIsSavingProfile] = useState(false);
useEffect(() => {
if (profile) {
setProfileData({
name: profile.name || "",
bio: profile.bio || "",
avatar: profile.avatar || "",
email: profile.email || "",
location: profile.location || "",
});
}
}, [profile]);
const [activeSection, setActiveSection] = useState("profile");
const contentRef = useRef<HTMLDivElement>(null);
const sectionRefs = useRef<Record<string, HTMLElement | null>>({});
const seedLinks = useMutation(api.browserLinks.seedLinks);
const seedTimeline = useMutation(api.careerTimeline.seedTimeline);
const seedBlogPosts = useMutation(api.blogPosts.seedBlogPosts);
const seedNavigation = useMutation(api.navigation.seedNavigationData);
const seedSEO = useMutation(api.seo.seedSEOData);
const seedProfile = useMutation(api.siteSettings.seedProfile);
const mutationMap: Record<string, () => Promise<unknown>> = {
links: seedLinks,
"career-timeline": seedTimeline,
"blog-posts": seedBlogPosts,
navigation: seedNavigation,
seo: seedSEO,
profile: seedProfile,
};
const [selectedSources, setSelectedSources] = useState<Set<string>>(
new Set()
);
const [isReseeding, setIsReseeding] = useState(false);
const [logs, setLogs] = useState<LogEntry[]>([]);
const {
toasts,
removeToast,
success,
error: showError,
loading: showLoading,
} = useToast();
const logEndRef = useRef<HTMLDivElement>(null);
const { startUpload } = useUploadThing("mediaUploader", {
onClientUploadComplete: async (res) => {
if (res && res[0]) {
setProfileData((prev) => ({ ...prev, avatar: res[0].url }));
await updateAvatar({ avatar: res[0].url });
setIsUploadingAvatar(false);
success("Avatar uploaded!");
}
},
onUploadError: (error: Error) => {
console.error("Upload error:", error);
setIsUploadingAvatar(false);
showError("Failed to upload avatar");
},
});
useEffect(() => {
const container = contentRef.current;
if (!container) return;
const handleScroll = () => {
const scrollTop = container.scrollTop;
const offset = 100;
for (const item of menuItems) {
const section = sectionRefs.current[item.id];
if (section) {
const sectionTop = section.offsetTop - offset;
const sectionBottom = sectionTop + section.offsetHeight;
if (scrollTop >= sectionTop && scrollTop < sectionBottom) {
setActiveSection(item.id);
break;
}
}
}
};
container.addEventListener("scroll", handleScroll);
return () => container.removeEventListener("scroll", handleScroll);
}, []);
useEffect(() => {
logEndRef.current?.scrollIntoView({ behavior: "smooth" });
}, [logs]);
const scrollToSection = (sectionId: string) => {
const section = sectionRefs.current[sectionId];
if (section && contentRef.current) {
contentRef.current.scrollTo({
top: section.offsetTop - 24,
behavior: "smooth",
});
}
};
const handleAvatarUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
const file = e.target.files?.[0];
if (!file) return;
setIsUploadingAvatar(true);
await startUpload([file]);
};
const handleSaveProfile = async () => {
setIsSavingProfile(true);
try {
await updateProfile({
name: profileData.name,
bio: profileData.bio,
avatar: profileData.avatar || undefined,
email: profileData.email || undefined,
location: profileData.location || undefined,
});
success("Profile saved!");
} catch (err) {
console.error("Failed to save profile:", err);
showError("Failed to save profile");
} finally {
setIsSavingProfile(false);
}
};
const addLog = (
message: string,
type: "info" | "success" | "error" = "info"
) => {
setLogs((prev) => [
...prev,
{
timestamp: new Date(),
message,
type,
},
]);
};
const dataSources: DataSource[] = [
{
id: "profile",
label: "Profile",
icon: User,
description: "Site owner name, bio, and social links",
},
{
id: "seo",
label: "SEO Metadata",
icon: FileText,
description: "Page titles and meta descriptions",
},
{
id: "links",
label: "Browser Links",
icon: LinkIcon,
description: "Bookmark collections and categories",
},
{
id: "career-timeline",
label: "Career Timeline",
icon: Calendar,
description: "Professional history and milestones",
},
{
id: "blog-posts",
label: "Blog Posts",
icon: MessageSquare,
description: "Sample blog content and articles",
},
{
id: "navigation",
label: "Navigation",
icon: Navigation,
description: "Header and footer menu items",
},
];
const toggleSource = (id: string) => {
const newSelected = new Set(selectedSources);
if (newSelected.has(id)) {
newSelected.delete(id);
} else {
newSelected.add(id);
}
setSelectedSources(newSelected);
};
const selectAll = () => {
setSelectedSources(new Set(dataSources.map((s) => s.id)));
};
const deselectAll = () => {
setSelectedSources(new Set());
};
const formatResult = (result: unknown): string => {
if (typeof result === "string") {
return result;
}
if (result && typeof result === "object") {
const obj = result as Record<string, unknown>;
if ("message" in obj) {
return String(obj.message);
}
if ("success" in obj) {
const parts: string[] = [];
if ("inserted" in obj) parts.push(`${obj.inserted} inserted`);
if ("updated" in obj) parts.push(`${obj.updated} updated`);
if ("total" in obj) parts.push(`${obj.total} total`);
return parts.length > 0 ? parts.join(", ") : "Success";
}
if ("count" in obj) {
return `${obj.count} records processed`;
}
}
return "Completed";
};
const handleReseed = async () => {
if (selectedSources.size === 0) {
showError("Please select at least one data source to reseed");
addLog("Reseed aborted: No data sources selected", "error");
return;
}
setIsReseeding(true);
addLog(
`Starting reseed for ${selectedSources.size} data source(s)...`,
"info"
);
let successCount = 0;
let errorCount = 0;
try {
for (const source of dataSources) {
if (selectedSources.has(source.id)) {
addLog(`Reseeding ${source.label}...`, "info");
try {
const mutation = mutationMap[source.id];
if (mutation) {
const result = await mutation();
addLog(`✓ ${source.label}: ${formatResult(result)}`, "success");
successCount++;
} else {
addLog(`✗ ${source.label}: No mutation found`, "error");
errorCount++;
}
} catch (error) {
const errorMsg = error instanceof Error ? error.message : "Failed";
addLog(`✗ ${source.label}: ${errorMsg}`, "error");
errorCount++;
}
}
}
const summary = `Reseed complete: ${successCount} succeeded, ${errorCount} failed`;
addLog(summary, errorCount === 0 ? "success" : "error");
if (errorCount === 0) {
success("All data sources reseeded successfully!");
} else {
showError(`Reseed completed with ${errorCount} error(s)`);
}
setTimeout(() => {
setSelectedSources(new Set());
}, 2000);
} catch (error) {
const errorMsg = "Unexpected error during reseed";
addLog(errorMsg, "error");
showError(errorMsg);
console.error("Reseed error:", error);
} finally {
setIsReseeding(false);
}
};
const clearLogs = () => {
setLogs([]);
};
return (
<div className="h-full flex gap-6">
<div className="w-56 shrink-0">
<div className="bg-panel border border-border rounded-2xl p-3 sticky top-0">
<nav className="space-y-1">
{menuItems.map((item) => (
<button
key={item.id}
onClick={() => scrollToSection(item.id)}
className={`w-full flex items-center gap-3 px-3 py-2.5 rounded-lg text-sm font-medium transition-all ${
activeSection === item.id
? "bg-accent text-on-accent"
: "text-muted hover:text-ink hover:bg-surface-hover"
}`}
>
<item.icon className="w-4 h-4 shrink-0" />
{item.label}
</button>
))}
</nav>
</div>
</div>
<section
id="profile"
ref={(el) => {
sectionRefs.current["profile"] = el;
}}
className="scroll-mt-6"
>
<div className="bg-panel border border-border rounded-2xl p-6">
<div className="flex items-center gap-3 mb-6">
<div className="p-2 bg-accent/10 rounded-lg">
<User className="w-5 h-5 text-accent" />
</div>
<div>
<h2 className="text-lg font-bold text-ink">Profile</h2>
<p className="text-sm text-muted">
Your personal information displayed across the site
</p>
</div>
</div>
<div className="space-y-6">
<div className="space-y-2">
<label
htmlFor="profile-name"
className="block text-sm font-medium text-ink"
>
Name
</label>
<Input
id="profile-name"
value={profileData.name}
onChange={(e) =>
setProfileData((prev) => ({
...prev,
name: e.target.value,
}))
}
placeholder="Your name"
className="max-w-md"
/>
</div>
<div className="pt-2">
<Button
onClick={handleSaveProfile}
variant="outline"
disabled={isSavingProfile}
className="gap-2"
>
{isSavingProfile ? (
<RefreshCw className="w-4 h-4 animate-spin" />
) : (
<Save className="w-4 h-4" />
)}
Save Profile
</Button>
</div>
</div>
</div>
</section>
<div className="flex items-center justify-between">
<p className="text-sm font-medium text-ink">Data Sources</p>
<div className="flex gap-2">
<button
onClick={selectAll}
className="text-xs text-accent hover:underline"
>
Select all
</button>
<span className="text-muted">|</span>
<button
onClick={deselectAll}
className="text-xs text-muted hover:text-ink"
>
Clear
</button>
</div>
</div>
<div className="grid grid-cols-2 gap-3">
{dataSources.map((source) => (
<button
key={source.id}
onClick={() => toggleSource(source.id)}
className={`p-4 rounded-xl border-2 text-left transition-all ${
selectedSources.has(source.id)
? "border-accent bg-accent/5"
: "border-border hover:border-accent/50"
}`}
>
<div className="flex items-start gap-3">
<div
className={`p-2 rounded-lg ${
selectedSources.has(source.id)
? "bg-accent/20 text-accent"
: "bg-base text-muted"
}`}
>
<source.icon className="w-4 h-4" />
</div>
<div>
<p
className={`font-medium text-sm ${
selectedSources.has(source.id)
? "text-ink"
: "text-muted"
}`}
>
{source.label}
</p>
<p className="text-xs text-muted mt-0.5">
{source.description}
</p>
</div>
</div>
</button>
))}
</div>
{logs.length > 0 && (
<div className="mt-4">
<div className="flex items-center justify-between mb-2">
<p className="text-sm font-medium text-ink">Activity Log</p>
<button
onClick={clearLogs}
className="text-xs text-muted hover:text-ink"
>
Clear
</button>
</div>
<div className="max-h-48 overflow-y-auto bg-base rounded-lg p-3 space-y-1 font-mono text-xs">
{logs.map((log, i) => (
<div
key={i}
className={`${
log.type === "success"
? "text-emerald-500"
: log.type === "error"
? "text-red-500"
: "text-muted"
}`}
>
<span className="opacity-50">
[{log.timestamp.toLocaleTimeString()}]
</span>{" "}
{log.message}
</div>
))}
<div ref={logEndRef} />
</div>
</div>
)}
</div>
</div>
</section>
</div>
</div>
);
};
export default SettingsTabEnhanced;

===== FILE: src/app/admin/components/ErrorDisplay.tsx =====
"use client";
import React from "react";
import { AlertCircle, AlertTriangle, Info } from "lucide-react";
type ErrorType =
| "SettingsError"
| "ValidationError"
| "BackupError"
| "HealthCheckError"
| "BlogError"
| "MediaError"
| "LinkError"
| "SEOError"
| "unknown";
interface ErrorDisplayProps {
error: Error | null;
onDismiss: () => void;
compact?: boolean;
}
export const ErrorDisplay: React.FC<ErrorDisplayProps> = ({
error,
onDismiss,
compact = false,
}) => {
if (!error) return null;
const getErrorType = (): ErrorType => {
if (error.name === "ValidationError") return "ValidationError";
if (error.name === "SettingsError") return "SettingsError";
if (error.name === "BackupError") return "BackupError";
if (error.name === "HealthCheckError") return "HealthCheckError";
if (error.name === "BlogError") return "BlogError";
if (error.name === "MediaError") return "MediaError";
if (error.name === "LinkError") return "LinkError";
if (error.name === "SEOError") return "SEOError";
return "unknown";
};
const getErrorConfig = (type: ErrorType) => {
const configs = {
ValidationError: {
icon: AlertTriangle,
bgColor: "bg-yellow-500/10",
borderColor: "border-yellow-500/30",
textColor: "text-yellow-700 dark:text-yellow-400",
title: "Validation Error",
},
SettingsError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Settings Error",
},
BackupError: {
icon: AlertCircle,
bgColor: "bg-orange-500/10",
borderColor: "border-orange-500/30",
textColor: "text-orange-700 dark:text-orange-400",
title: "Backup Error",
},
HealthCheckError: {
icon: Info,
bgColor: "bg-blue-500/10",
borderColor: "border-blue-500/30",
textColor: "text-blue-700 dark:text-blue-400",
title: "Health Check Error",
},
BlogError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Blog Error",
},
MediaError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Media Error",
},
LinkError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Link Error",
},
SEOError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "SEO Error",
},
unknown: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Error",
},
};
return configs[type];
};
const type = getErrorType();
const config = getErrorConfig(type);
const Icon = config.icon;
if (compact) {
return (
<div
className={`p-3 rounded-lg border ${config.bgColor} ${config.borderColor} flex items-start gap-2`}
>
<Icon className={`w-4 h-4 shrink-0 mt-0.5 ${config.textColor}`} />
<p className={`text-sm ${config.textColor}`}>{error.message}</p>
</div>
);
}
return (
<div
className={`p-4 rounded-lg border ${config.bgColor} ${config.borderColor} flex items-start gap-3`}
>
<Icon className={`w-5 h-5 shrink-0 mt-0.5 ${config.textColor}`} />
<div className="flex-1">
<h4 className={`font-semibold ${config.textColor}`}>{config.title}</h4>
<p className={`text-sm mt-1 ${config.textColor}`}>{error.message}</p>
</div>
<button
onClick={onDismiss}
className={`text-lg shrink-0 ${config.textColor} hover:opacity-70`}
>
×
</button>
</div>
);
};

===== FILE: src/app/admin/components/HtmlEditorEnhanced.tsx =====
"use client";
import React, { useRef, useState } from "react";
import {
Bold,
Italic,
Underline,
List,
ListOrdered,
Heading2,
Code,
LinkIcon,
Image,
} from "lucide-react";
import { Button } from "@/components/ui/button";
interface HtmlEditorProps {
value: string;
onChange: (value: string) => void;
placeholder?: string;
onImageClick?: () => void;
}
export const HtmlEditorEnhanced: React.FC<HtmlEditorProps> = ({
value,
onChange,
placeholder = "Enter content...",
onImageClick,
}) => {
const editorRef = useRef<HTMLDivElement>(null);
const [isHtml, setIsHtml] = useState(false);
const execCommand = (command: string, value?: string) => {
document.execCommand(command, false, value);
editorRef.current?.focus();
updateContent();
};
const updateContent = () => {
if (editorRef.current) {
onChange(editorRef.current.innerHTML);
}
};
const insertLink = () => {
const url = prompt("Enter URL:");
if (url) {
execCommand("createLink", url);
}
};
const toggleHTMLView = () => {
if (isHtml && editorRef.current) {
editorRef.current.innerHTML = value;
}
setIsHtml(!isHtml);
};
return (
<div className="border border-border rounded-lg overflow-hidden bg-panel">
{!isHtml ? (
<div
ref={editorRef}
onInput={updateContent}
contentEditable
className="min-h-64 p-4 focus:outline-none text-ink prose prose-invert max-w-none"
suppressContentEditableWarning
/>
) : (
<textarea
value={value}
onChange={(e) => onChange(e.target.value)}
className="w-full min-h-64 p-4 focus:outline-none text-ink bg-panel font-mono text-sm"
placeholder={placeholder}
/>
)}
</div>
);
};

===== FILE: src/app/admin/components/HtmlEditor.tsx =====
"use client";
import React, { useRef, useEffect } from "react";
import {
Bold,
Italic,
Underline,
List,
ListOrdered,
Heading2,
Code,
} from "lucide-react";
interface HtmlEditorProps {
value: string;
onChange: (value: string) => void;
placeholder?: string;
}
export const HtmlEditor: React.FC<HtmlEditorProps> = ({
value,
onChange,
placeholder = "Enter content...",
}) => {
const editorRef = useRef<HTMLDivElement>(null);
const [isHTML, setIsHTML] = React.useState(false);
useEffect(() => {
if (editorRef.current && !isHTML) {
editorRef.current.innerHTML = value;
}
}, []);
const execCommand = (command: string, value?: string) => {
document.execCommand(command, false, value);
editorRef.current?.focus();
updateContent();
};
const updateContent = () => {
if (editorRef.current) {
onChange(editorRef.current.innerHTML);
}
};
const insertLink = () => {
const url = prompt("Enter URL:");
if (url) {
execCommand("createLink", url);
}
};
const toggleHTMLView = () => {
if (isHTML && editorRef.current) {
editorRef.current.innerHTML = value;
}
setIsHTML(!isHTML);
};
return (
<div className="border border-border rounded-lg overflow-hidden bg-panel">
{!isHTML ? (
<div
ref={editorRef}
onInput={updateContent}
contentEditable
className="min-h-64 p-4 focus:outline-none text-ink prose prose-invert max-w-none"
suppressContentEditableWarning
/>
) : (
<textarea
value={value}
onChange={(e) => onChange(e.target.value)}
className="w-full min-h-64 p-4 focus:outline-none text-ink bg-panel font-mono text-sm"
placeholder={placeholder}
/>
)}
</div>
);
};

===== FILE: src/app/admin/components/LoadingSpinner.tsx =====
"use client";
import React from "react";
import { Loader2 } from "lucide-react";
interface LoadingSpinnerProps {
message?: string;
compact?: boolean;
}
export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
message = "Loading...",
compact = false,
}) => {
if (compact) {
return (
<div className="flex items-center gap-2">
<Loader2 className="w-4 h-4 animate-spin text-accent" />
<span className="text-sm text-muted">{message}</span>
</div>
);
}
return (
<div className="flex flex-col items-center justify-center py-12">
<Loader2 className="w-8 h-8 animate-spin text-accent mb-3" />
<p className="text-muted">{message}</p>
</div>
);
};

===== FILE: src/app/admin/components/LogViewer.tsx =====
"use client";
import React, { useEffect, useRef } from "react";
interface LogViewerProps {
logs: string[];
maxHeight?: string;
compact?: boolean;
}
export const LogViewer: React.FC<LogViewerProps> = ({
logs,
maxHeight = "max-h-64",
compact = false,
}) => {
const endRef = useRef<HTMLDivElement>(null);
useEffect(() => {
endRef.current?.scrollIntoView({ behavior: "smooth" });
}, [logs]);
if (logs.length === 0) return null;
if (compact) {
return (
<div className={`${maxHeight} overflow-y-auto bg-base rounded-lg p-3`}>
<div className="space-y-1">
{logs.map((log, i) => (
<p
key={i}
className="text-xs text-muted font-mono wrap-break-words"
>
{log}
</p>
))}
<div ref={endRef} />
</div>
</div>
);
}
return (
<div className={`${maxHeight} overflow-y-auto bg-base rounded-lg p-4`}>
<p className="text-sm font-semibold text-muted mb-3">Operation Log</p>
<div className="space-y-1">
{logs.map((log, i) => (
<p key={i} className="text-xs text-muted font-mono wrap-break-words">
{log}
</p>
))}
<div ref={endRef} />
</div>
</div>
);
};

===== FILE: src/app/admin/components/MediaDrawer.tsx =====
"use client";
import React, { useState } from "react";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import {
Drawer,
DrawerContent,
DrawerHeader,
DrawerTitle,
DrawerDescription,
} from "@/components/ui/drawer";
import { Search, Check } from "lucide-react";
import Image from "next/image";
interface MediaItem {
_id: string;
url: string;
filename: string;
altText?: string;
size?: number;
}
interface MediaDrawerProps {
isOpen: boolean;
onClose: () => void;
onSelect: (imageUrl: string) => void;
title?: string;
description?: string;
}
export const MediaDrawer: React.FC<MediaDrawerProps> = ({
isOpen,
onClose,
onSelect,
title = "Select Image",
description = "Choose an image from your media library",
}) => {
const [searchQuery, setSearchQuery] = useState("");
const allMedia = useQuery(api.media.getAll) ?? [];
const filteredMedia = allMedia.filter((media: MediaItem) => {
if (!searchQuery) return true;
const query = searchQuery.toLowerCase();
return (
media.filename.toLowerCase().includes(query) ||
media.altText?.toLowerCase().includes(query)
);
});
const handleSelect = (imageUrl: string) => {
onSelect(imageUrl);
onClose();
};
return (
<Drawer open={isOpen} onOpenChange={onClose}>
<DrawerContent className="h-[90vh] flex flex-col">
<DrawerHeader>
<DrawerTitle>{title}</DrawerTitle>
<DrawerDescription>{description}</DrawerDescription>
</DrawerHeader>
<div className="flex-1 overflow-hidden flex flex-col px-6">
<div className="flex-1 overflow-y-auto">
{filteredMedia.length === 0 ? (
<div className="text-center py-12">
<p className="text-muted">
{searchQuery ? "No images found" : "No images in library"}
</p>
</div>
) : (
<div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
{filteredMedia.map((media: MediaItem) => (
<button
key={media._id}
onClick={() => handleSelect(media.url)}
className="group relative aspect-square rounded-lg overflow-hidden border border-border hover:border-accent transition"
>
<Image
src={media.url}
alt={media.altText || media.filename}
fill
className="object-cover group-hover:scale-105 transition"
sizes="150px"
/>
<div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition flex items-center justify-center">
<Check className="w-6 h-6 text-white" />
</div>
<div className="absolute bottom-0 left-0 right-0 bg-black/60 p-2 opacity-0 group-hover:opacity-100 transition">
<p className="text-xs text-white truncate">
{media.filename}
</p>
</div>
</button>
))}
</div>
)}
</div>
</div>
</DrawerContent>
</Drawer>
);
};

===== FILE: src/app/admin/components/SuccessDisplay.tsx =====
"use client";
import React from "react";
import { CheckCircle } from "lucide-react";
interface SuccessDisplayProps {
message: string;
onDismiss: () => void;
compact?: boolean;
}
export const SuccessDisplay: React.FC<SuccessDisplayProps> = ({
message,
onDismiss,
compact = false,
}) => {
if (compact) {
return (
<div className="p-3 rounded-lg border bg-green-500/10 border-green-500/30 flex items-start gap-2">
<CheckCircle className="w-4 h-4 shrink-0 mt-0.5 text-green-700 dark:text-green-400" />
<p className="text-sm text-green-700 dark:text-green-400">{message}</p>
</div>
);
}
return (
<div className="p-4 rounded-lg border bg-green-500/10 border-green-500/30 flex items-start gap-3">
<CheckCircle className="w-5 h-5 shrink-0 mt-0.5 text-green-700 dark:text-green-400" />
<div className="flex-1">
<p className="text-sm text-green-700 dark:text-green-400">{message}</p>
</div>
<button
onClick={onDismiss}
className="text-lg shrink-0 text-green-700 dark:text-green-400 hover:opacity-70"
>
×
</button>
</div>
);
};

===== FILE: src/app/admin/components/Toastcontainer.tsx =====
"use client";
import { CheckCircle, AlertCircle, Info, X, Loader2 } from "lucide-react";
type ToastType = "success" | "error" | "info" | "loading";
interface Toast {
id: string;
message: string;
type: ToastType;
}
interface ToastContainerProps {
toasts: Toast[];
onRemove: (id: string) => void;
}
export const ToastContainer = ({ toasts, onRemove }: ToastContainerProps) => {
if (toasts.length === 0) return null;
return (
<div className="fixed top-4 right-4 z-50 flex flex-col gap-2 max-w-sm">
{toasts.map((toast) => (
<div
key={toast.id}
className={`px-4 py-3 rounded-lg shadow-lg border flex items-center gap-3 animate-in slide-in-from-right-5 fade-in duration-200 ${
toast.type === "success"
? "bg-emerald-500/10 border-emerald-500/30 text-emerald-600 dark:text-emerald-400"
: toast.type === "error"
? "bg-red-500/10 border-red-500/30 text-red-600 dark:text-red-400"
: toast.type === "loading"
? "bg-blue-500/10 border-blue-500/30 text-blue-600 dark:text-blue-400"
: "bg-zinc-500/10 border-zinc-500/30 text-zinc-600 dark:text-zinc-400"
}`}
>
{toast.type === "success" && (
<CheckCircle className="w-4 h-4 shrink-0" />
)}
{toast.type === "error" && (
<AlertCircle className="w-4 h-4 shrink-0" />
)}
{toast.type === "info" && <Info className="w-4 h-4 shrink-0" />}
{toast.type === "loading" && (
<Loader2 className="w-4 h-4 shrink-0 animate-spin" />
)}
<span className="text-sm flex-1">{toast.message}</span>
{toast.type !== "loading" && (
<button
onClick={() => onRemove(toast.id)}
className="p-1 hover:bg-black/10 dark:hover:bg-white/10 rounded transition shrink-0"
>
<X className="w-3 h-3" />
</button>
)}
</div>
))}
</div>
);
};

===== FILE: src/app/admin/components/ValidationFeedback.tsx =====
"use client";
import React from "react";
import { AlertCircle, CheckCircle2, Info } from "lucide-react";
interface ValidationFeedbackProps {
errors: string[];
warnings: string[];
success: string[];
}
export const ValidationFeedback: React.FC<ValidationFeedbackProps> = ({
errors,
warnings,
success,
}) => {
if (errors.length === 0 && warnings.length === 0 && success.length === 0) {
return null;
}
return (
<div className="space-y-2">
{errors.map((error, i) => (
<div
key={`error-${i}`}
className="p-3 rounded-lg border bg-red-500/10 border-red-500/30 flex items-start gap-2"
>
<AlertCircle className="w-4 h-4 shrink-0 mt-0.5 text-red-700 dark:text-red-400" />
<p className="text-sm text-red-700 dark:text-red-400">{error}</p>
</div>
))}
{warnings.map((warning, i) => (
<div
key={`warning-${i}`}
className="p-3 rounded-lg border bg-yellow-500/10 border-yellow-500/30 flex items-start gap-2"
>
<Info className="w-4 h-4 shrink-0 mt-0.5 text-yellow-700 dark:text-yellow-400" />
<p className="text-sm text-yellow-700 dark:text-yellow-400">
{warning}
</p>
</div>
))}
{success.map((msg, i) => (
<div
key={`success-${i}`}
className="p-3 rounded-lg border bg-green-500/10 border-green-500/30 flex items-start gap-2"
>
<CheckCircle2 className="w-4 h-4 shrink-0 mt-0.5 text-green-700 dark:text-green-400" />
<p className="text-sm text-green-700 dark:text-green-400">{msg}</p>
</div>
))}
</div>
);
};

===== FILE: src/app/admin/EffectErrorDisplay.tsx =====
"use client";
import React from "react";
import { AlertCircle, CheckCircle, Info, AlertTriangle } from "lucide-react";
type ErrorType =
| "SettingsError"
| "ValidationError"
| "BackupError"
| "HealthCheckError"
| "unknown";
interface EffectErrorDisplayProps {
error: Error | null;
onDismiss: () => void;
}
export const EffectErrorDisplay: React.FC<EffectErrorDisplayProps> = ({
error,
onDismiss,
}) => {
if (!error) return null;
const getErrorType = (): ErrorType => {
if (error.name === "ValidationError") return "ValidationError";
if (error.name === "SettingsError") return "SettingsError";
if (error.name === "BackupError") return "BackupError";
if (error.name === "HealthCheckError") return "HealthCheckError";
return "unknown";
};
const getErrorConfig = (type: ErrorType) => {
const configs = {
ValidationError: {
icon: AlertTriangle,
bgColor: "bg-yellow-500/10",
borderColor: "border-yellow-500/30",
textColor: "text-yellow-700 dark:text-yellow-400",
title: "Validation Error",
},
SettingsError: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Settings Error",
},
BackupError: {
icon: AlertCircle,
bgColor: "bg-orange-500/10",
borderColor: "border-orange-500/30",
textColor: "text-orange-700 dark:text-orange-400",
title: "Backup Error",
},
HealthCheckError: {
icon: Info,
bgColor: "bg-blue-500/10",
borderColor: "border-blue-500/30",
textColor: "text-blue-700 dark:text-blue-400",
title: "Health Check Error",
},
unknown: {
icon: AlertCircle,
bgColor: "bg-red-500/10",
borderColor: "border-red-500/30",
textColor: "text-red-700 dark:text-red-400",
title: "Error",
},
};
return configs[type];
};
const type = getErrorType();
const config = getErrorConfig(type);
const Icon = config.icon;
return (
<div
className={`p-4 rounded-lg border ${config.bgColor} ${config.borderColor} flex items-start gap-3`}
>
<Icon className={`w-5 h-5 shrink-0 mt-0.5 ${config.textColor}`} />
<div className="flex-1">
<h4 className={`font-semibold ${config.textColor}`}>
{config.title}
</h4>
<p className={`text-sm mt-1 ${config.textColor}`}>
{error.message}
</p>
</div>
<button
onClick={onDismiss}
className={`text-lg shrink-0 ${config.textColor} hover:opacity-70`}
>
×
</button>
</div>
);
};
export const EffectSuccessDisplay: React.FC<{ message: string; onDismiss: () => void }> = ({
message,
onDismiss,
}) => (
<div className="p-4 rounded-lg border bg-green-500/10 border-green-500/30 flex items-start gap-3">
<CheckCircle className="w-5 h-5 shrink-0 mt-0.5 text-green-700 dark:text-green-400" />
<div className="flex-1">
<p className="text-sm text-green-700 dark:text-green-400">{message}</p>
</div>
<button
onClick={onDismiss}
className="text-lg shrink-0 text-green-700 dark:text-green-400 hover:opacity-70"
>
×
</button>
</div>
);

===== FILE: src/app/admin/effects/blog-effects.ts =====
import { Effect, pipe, Either } from "effect";
export interface BlogPostData {
title: string;
slug: string;
excerpt: string;
content: string;
coverImage?: string;
tags?: string[];
published: boolean;
createdAt?: number;
}
export interface BlogValidationResult {
isValid: boolean;
errors: string[];
warnings: string[];
}
export class BlogError extends Error {
readonly _tag = "BlogError";
constructor(message: string) {
super(message);
this.name = "BlogError";
}
}
export class BlogValidationError extends Error {
readonly _tag = "BlogValidationError";
constructor(message: string) {
super(message);
this.name = "BlogValidationError";
}
}
export class SlugError extends Error {
readonly _tag = "SlugError";
constructor(message: string) {
super(message);
this.name = "SlugError";
}
}
export class ImageUploadError extends Error {
readonly _tag = "ImageUploadError";
constructor(message: string) {
super(message);
this.name = "ImageUploadError";
}
}
export const generateSlug = (title: string): Effect.Effect<string, SlugError> =>
Effect.gen(function* () {
if (!title || title.trim().length === 0) {
yield* Effect.fail(
new SlugError("Title is required for slug generation")
);
}
const slug = title
.toLowerCase()
.replace(/[^a-z0-9]+/g, "-")
.replace(/(^-|-$)/g, "");
if (slug.length === 0) {
yield* Effect.fail(new SlugError("Generated slug is empty"));
}
return slug;
});
export const validateBlogPost = (post: Partial<BlogPostData>) =>
Effect.gen(function* () {
const errors: string[] = [];
const warnings: string[] = [];
if (!post.title?.trim()) {
errors.push("Title is required");
} else if (post.title.length > 200) {
warnings.push("Title is quite long (consider shortening)");
}
if (!post.slug?.trim()) {
errors.push("Slug is required");
} else if (!/^[a-z0-9-]+$/.test(post.slug)) {
errors.push(
"Slug can only contain lowercase letters, numbers, and hyphens"
);
}
if (!post.excerpt?.trim()) {
errors.push("Excerpt is required");
} else if (post.excerpt.length < 50) {
warnings.push("Excerpt is quite short");
} else if (post.excerpt.length > 300) {
warnings.push("Excerpt exceeds recommended length (300 chars)");
}
if (!post.content?.trim()) {
errors.push("Content is required");
} else if (post.content.length < 200) {
warnings.push("Content seems too short for a blog post");
}
if (!post.tags || post.tags.length === 0) {
warnings.push("Consider adding tags for better SEO");
} else if (post.tags.length > 10) {
warnings.push("Too many tags (5-7 is optimal)");
}
if (errors.length > 0) {
yield* Effect.fail(
new BlogValidationError(`Validation errors: ${errors.join(", ")}`)
);
}
return {
isValid: true,
errors,
warnings,
} as BlogValidationResult;
});
export const createBlogPostEffect = (post: Partial<BlogPostData>) =>
pipe(
validateBlogPost(post),
Effect.flatMap(() => generateSlug(post.title || "")),
Effect.flatMap((slug) =>
Effect.gen(function* () {
return {
...post,
slug,
createdAt: Date.now(),
updatedAt: Date.now(),
};
}).pipe(
Effect.catchAll(() =>
Effect.fail(new BlogError("Failed to create blog post"))
)
)
)
);
export const uploadCoverImageEffect = (file: File, maxRetries = 3) =>
Effect.gen(function* () {
const validMimeTypes = ["image/jpeg", "image/png", "image/webp"];
if (!validMimeTypes.includes(file.type)) {
yield* Effect.fail(
new ImageUploadError(
`Invalid image type. Allowed: ${validMimeTypes.join(", ")}`
)
);
}
const maxSize = 5 * 1024 * 1024;
if (file.size > maxSize) {
yield* Effect.fail(
new ImageUploadError(
`Image too large. Max size: ${maxSize / 1024 / 1024}MB`
)
);
}
yield* Effect.log(`Uploading image: ${file.name}`);
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 1000))
).pipe(
Effect.catchAll(() => Effect.fail(new ImageUploadError("Upload failed")))
);
return {
name: file.name,
size: file.size,
url: `https:
};
});
export const generateContentPreview = (content: string, maxLength = 200) =>
Effect.gen(function* () {
if (!content || content.length === 0) {
yield* Effect.fail(new BlogError("Content is empty"));
}
const cleanContent = content
.replace(/^<[^>]+>/g, "")
.replace(/\*\*/g, "")
.replace(/\*/g, "")
.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
const preview = cleanContent.substring(0, maxLength).trim();
return preview + (cleanContent.length > maxLength ? "..." : "");
});
export const togglePublishBulk = (postIds: string[], published: boolean) =>
Effect.gen(function* () {
if (postIds.length === 0) {
yield* Effect.fail(new BlogValidationError("No posts selected"));
}
yield* Effect.log(
`${published ? "Publishing" : "Unpublishing"} ${postIds.length} posts...`
);
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 500))
).pipe(
Effect.catchAll(() => Effect.fail(new BlogError("Bulk operation failed")))
);
return {
updated: postIds.length,
status: published ? "published" : "unpublished",
timestamp: Date.now(),
};
});
export const checkDuplicateSlugs = (slug: string, allSlugs: string[]) =>
Effect.gen(function* () {
const isDuplicate = allSlugs.includes(slug);
if (isDuplicate) {
yield* Effect.fail(new SlugError(`Slug "${slug}" is already in use`));
}
return true;
});

===== FILE: src/app/admin/effects/career-effects.ts =====
import { Effect, pipe } from "effect";
export interface CareerEvent {
year: string;
title: string;
description: string;
location?: string;
iconName: string;
order: number;
}
export interface CareerTimeline {
events: CareerEvent[];
startYear: number;
endYear: number;
}
export class CareerError extends Error {
readonly _tag = "CareerError";
constructor(message: string) {
super(message);
this.name = "CareerError";
}
}
export class CareerValidationError extends Error {
readonly _tag = "CareerValidationError";
constructor(message: string) {
super(message);
this.name = "CareerValidationError";
}
}
export class IconError extends Error {
readonly _tag = "IconError";
constructor(message: string) {
super(message);
this.name = "IconError";
}
}
const VALID_ICONS = [
"GraduationCap",
"Video",
"Star",
"Lightbulb",
"Mountain",
"Home",
"Users",
"Code2",
"Briefcase",
"Award",
"BookOpen",
"Coffee",
"Rocket",
"Target",
];
export const validateIcon = (iconName: string) =>
Effect.gen(function* () {
if (!iconName || iconName.trim().length === 0) {
yield* Effect.fail(new IconError("Icon name is required"));
}
if (!VALID_ICONS.includes(iconName)) {
yield* Effect.fail(
new IconError(
`Invalid icon: ${iconName}. Valid icons: ${VALID_ICONS.join(", ")}`
)
);
}
return iconName;
});
export const validateCareerEvent = (event: Partial<CareerEvent>) =>
Effect.gen(function* () {
if (!event.year || event.year.trim().length === 0) {
yield* Effect.fail(new CareerValidationError("Year is required"));
}
if (!event.title || event.title.trim().length === 0) {
yield* Effect.fail(new CareerValidationError("Title is required"));
} else if (event.title.length > 200) {
yield* Effect.fail(
new CareerValidationError("Title must be less than 200 characters")
);
}
if (!event.description || event.description.trim().length === 0) {
yield* Effect.fail(new CareerValidationError("Description is required"));
} else if (event.description.length < 20) {
yield* Effect.fail(
new CareerValidationError("Description must be at least 20 characters")
);
}
yield* validateIcon(event.iconName || "");
return event as CareerEvent;
});
export const createCareerEventEffect = (event: Partial<CareerEvent>) =>
pipe(
validateCareerEvent(event),
Effect.flatMap((validEvent) =>
Effect.gen(function* () {
return {
...validEvent,
createdAt: Date.now(),
};
}).pipe(
Effect.catchAll(() =>
Effect.fail(new CareerError("Failed to create career event"))
)
)
)
);
export const reorderTimelineEffect = (
events: Array<{ id: string; order: number }>
) =>
Effect.gen(function* () {
if (events.length === 0) {
yield* Effect.fail(new CareerValidationError("No events to reorder"));
}
const orders = events.map((e) => e.order);
const maxOrder = Math.max(...orders);
const minOrder = Math.min(...orders);
if (maxOrder - minOrder !== events.length - 1) {
yield* Effect.fail(new CareerValidationError("Invalid order sequence"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 400))
).pipe(
Effect.catchAll(() =>
Effect.fail(new CareerError("Failed to reorder timeline"))
)
);
return { success: true, reordered: events.length };
});
export const deleteCareerEventEffect = (eventId: string) =>
Effect.gen(function* () {
if (!eventId) {
yield* Effect.fail(new CareerValidationError("Event ID is required"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() =>
Effect.fail(new CareerError("Failed to delete event"))
)
);
return { success: true, deleted: eventId };
});
export const analyzeTimelineEffect = (events: CareerEvent[]) =>
Effect.gen(function* () {
if (events.length === 0) {
yield* Effect.fail(new CareerValidationError("No events in timeline"));
}
const years = events
.map((e) => parseInt(e.year.split("-")[0]))
.filter((y) => !isNaN(y));
const startYear = Math.min(...years);
const endYear = Math.max(...years);
const yearsSpan = endYear - startYear;
return {
eventCount: events.length,
startYear,
endYear,
yearsSpan,
averageEventsPerYear: (events.length / (yearsSpan + 1)).toFixed(2),
};
});

===== FILE: src/app/admin/effects/engagement-effects.ts =====
import { Effect, pipe } from "effect";
export interface BlogComment {
id: string;
postId: string;
postTitle: string;
authorName: string;
authorEmail: string;
content: string;
approved: boolean;
createdAt: number;
}
export interface CommentFilter {
searchQuery?: string;
approved?: boolean;
postId?: string;
}
export interface PostLikeStats {
postId: string;
postTitle: string;
likesCount: number;
percentageOfTotal: number;
}
export class EngagementError extends Error {
readonly _tag = "EngagementError";
constructor(message: string) {
super(message);
this.name = "EngagementError";
}
}
export class EngagementValidationError extends Error {
readonly _tag = "EngagementValidationError";
constructor(message: string) {
super(message);
this.name = "EngagementValidationError";
}
}
export const validateComment = (comment: Partial<BlogComment>) =>
Effect.gen(function* () {
const authorName = comment.authorName ?? "";
const authorEmail = comment.authorEmail ?? "";
const content = comment.content ?? "";
if (!authorName || authorName.trim().length === 0) {
yield* Effect.fail(
new EngagementValidationError("Author name is required")
);
}
if (!authorEmail || authorEmail.trim().length === 0) {
yield* Effect.fail(
new EngagementValidationError("Author email is required")
);
}
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!emailRegex.test(authorEmail)) {
yield* Effect.fail(
new EngagementValidationError(`Invalid email: ${authorEmail}`)
);
}
if (!content || content.trim().length === 0) {
yield* Effect.fail(
new EngagementValidationError("Comment content is required")
);
}
if (content.length < 5) {
yield* Effect.fail(
new EngagementValidationError("Comment must be at least 5 characters")
);
}
if (content.length > 2000) {
yield* Effect.fail(
new EngagementValidationError(
"Comment exceeds maximum length (2000 characters)"
)
);
}
return comment as BlogComment;
});
export const filterCommentsEffect = (
comments: BlogComment[],
filter: CommentFilter
) =>
Effect.gen(function* () {
let filtered = [...comments];
if (filter.searchQuery) {
const query = filter.searchQuery.toLowerCase();
filtered = filtered.filter(
(c) =>
c.authorName.toLowerCase().includes(query) ||
(c.content?.toLowerCase().includes(query) ?? false) ||
c.postTitle.toLowerCase().includes(query)
);
}
if (filter.approved !== undefined) {
filtered = filtered.filter((c) => c.approved === filter.approved);
}
if (filter.postId) {
filtered = filtered.filter((c) => c.postId === filter.postId);
}
return filtered;
});
export const approveCommentEffect = (commentId: string) =>
Effect.gen(function* () {
if (!commentId) {
yield* Effect.fail(
new EngagementValidationError("Comment ID is required")
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 200))
).pipe(
Effect.catchAll(() =>
Effect.fail(new EngagementError("Failed to approve comment"))
)
);
return { success: true, commentId };
});
export const bulkApproveCommentsEffect = (commentIds: string[]) =>
Effect.gen(function* () {
if (commentIds.length === 0) {
yield* Effect.fail(new EngagementValidationError("No comments selected"));
}
if (commentIds.length > 100) {
yield* Effect.fail(
new EngagementValidationError(
"Cannot approve more than 100 comments at once"
)
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 500))
).pipe(
Effect.catchAll(() =>
Effect.fail(new EngagementError("Bulk approve failed"))
)
);
return { success: true, approved: commentIds.length };
});
export const rejectCommentEffect = (commentId: string) =>
Effect.gen(function* () {
if (!commentId) {
yield* Effect.fail(
new EngagementValidationError("Comment ID is required")
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 200))
).pipe(
Effect.catchAll(() =>
Effect.fail(new EngagementError("Failed to reject comment"))
)
);
return { success: true, rejected: commentId };
});
export const deleteCommentEffect = (commentId: string) =>
Effect.gen(function* () {
if (!commentId) {
yield* Effect.fail(
new EngagementValidationError("Comment ID is required")
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() =>
Effect.fail(new EngagementError("Failed to delete comment"))
)
);
return { success: true, deleted: commentId };
});
export const calculateLikeStatsEffect = (
posts: Array<{ id: string; title: string; likesCount: number }>
) =>
Effect.gen(function* () {
if (posts.length === 0) {
yield* Effect.fail(new EngagementValidationError("No posts available"));
}
const totalLikes = posts.reduce((sum, p) => sum + p.likesCount, 0);
const stats: PostLikeStats[] = posts.map((post) => ({
postId: post.id,
postTitle: post.title,
likesCount: post.likesCount,
percentageOfTotal:
totalLikes > 0 ? (post.likesCount / totalLikes) * 100 : 0,
}));
return {
stats,
total: totalLikes,
average: totalLikes / posts.length,
topPost: stats.reduce((prev, current) =>
prev.likesCount > current.likesCount ? prev : current
),
};
});

