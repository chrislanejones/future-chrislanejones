
===== FILE: src/app/admin/effects/links-effects.ts =====
import { Effect, pipe } from "effect";
export interface BrowserLink {
_id: string;
href: string;
label: string;
domain: string;
favicon?: string;
category: string;
color: string;
order: number;
featured?: boolean;
createdAt: number;
updatedAt: number;
}
export interface LinkCategory {
category: string;
color: string;
count: number;
}
export interface LinkValidationResult {
isValid: boolean;
errors: string[];
warnings: string[];
}
export class LinkError extends Error {
readonly _tag = "LinkError";
constructor(message: string) {
super(message);
this.name = "LinkError";
}
}
export class LinkValidationError extends Error {
readonly _tag = "LinkValidationError";
constructor(message: string) {
super(message);
this.name = "LinkValidationError";
}
}
export class CategoryError extends Error {
readonly _tag = "CategoryError";
constructor(message: string) {
super(message);
this.name = "CategoryError";
}
}
export const validateUrl = (url: string) =>
Effect.gen(function* () {
if (!url || url.trim().length === 0) {
yield* Effect.fail(new LinkValidationError("URL is required"));
}
try {
new URL(url);
} catch {
yield* Effect.fail(new LinkValidationError(`Invalid URL format: ${url}`));
}
return url;
});
export const validateLink = (link: Partial<BrowserLink>) =>
Effect.gen(function* () {
const errors: string[] = [];
const warnings: string[] = [];
if (!link.href?.trim()) {
errors.push("URL is required");
} else {
try {
new URL(link.href);
} catch {
errors.push("Invalid URL format");
}
}
if (!link.label?.trim()) {
errors.push("Label is required");
} else if (link.label.length > 100) {
warnings.push("Label is quite long (consider shortening)");
}
if (!link.category?.trim()) {
errors.push("Category is required");
}
if (!link.color) {
warnings.push("No color specified, will use default");
}
if (errors.length > 0) {
yield* Effect.fail(
new LinkValidationError(`Validation errors: ${errors.join(", ")}`)
);
}
return {
isValid: true,
errors,
warnings,
} as LinkValidationResult;
});
export const extractDomain = (url: string) =>
Effect.gen(function* () {
try {
const parsedUrl = new URL(url);
return parsedUrl.hostname;
} catch {
yield* Effect.fail(
new LinkError(`Failed to extract domain from: ${url}`)
);
}
return "";
});
export const createLinkEffect = (link: Partial<BrowserLink>) =>
pipe(
validateLink(link),
Effect.flatMap(() => extractDomain(link.href || "")),
Effect.flatMap((domain) =>
Effect.gen(function* () {
return {
...link,
domain,
featured: link.featured ?? false,
createdAt: Date.now(),
updatedAt: Date.now(),
};
}).pipe(
Effect.catchAll(() =>
Effect.fail(new LinkError("Failed to create link"))
)
)
)
);
export const toggleFeaturedEffect = (link: BrowserLink) =>
Effect.gen(function* () {
if (!link._id) {
yield* Effect.fail(new LinkValidationError("Link ID is required"));
}
yield* Effect.log(
`Toggling featured status for "${link.label}" to ${!link.featured}`
);
return {
...link,
featured: !link.featured,
updatedAt: Date.now(),
};
});
export const deleteCategoryEffect = (category: string, linkCount: number) =>
Effect.gen(function* () {
if (!category || category.trim().length === 0) {
yield* Effect.fail(new CategoryError("Category name is required"));
}
if (linkCount > 0) {
yield* Effect.log(
`Deleting category "${category}" with ${linkCount} links`
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() =>
Effect.fail(new CategoryError("Failed to delete category"))
)
);
return {
deleted: true,
category,
linksDeleted: linkCount,
};
});
export const filterLinksByCategoryEffect = (
links: BrowserLink[],
category: string
) =>
Effect.gen(function* () {
if (!category) {
return links;
}
return links.filter((link) => link.category === category);
});
export const getFeaturedLinksEffect = (links: BrowserLink[]) =>
Effect.gen(function* () {
return links.filter((link) => link.featured === true);
});
export const sortLinksEffect = (links: BrowserLink[]) =>
Effect.gen(function* () {
return [...links].sort((a, b) => a.order - b.order);
});
export const groupLinksByCategoryEffect = (links: BrowserLink[]) =>
Effect.gen(function* () {
const grouped = new Map<string, BrowserLink[]>();
for (const link of links) {
const category = link.category;
if (!grouped.has(category)) {
grouped.set(category, []);
}
grouped.get(category)!.push(link);
}
return grouped;
});

===== FILE: src/app/admin/effects/media-effects.ts =====
import { Effect, pipe, Either } from "effect";
export interface MediaFile {
id?: string;
url: string;
filename: string;
size: number;
mimeType: string;
altText?: string;
assignedToType?: string;
assignedToId?: string;
assignedToTitle?: string;
}
export interface UploadProgress {
filename: string;
progress: number;
status: "pending" | "uploading" | "success" | "failed";
error?: string;
}
export class MediaError extends Error {
readonly _tag = "MediaError";
constructor(message: string) {
super(message);
this.name = "MediaError";
}
}
export class UploadError extends Error {
readonly _tag = "UploadError";
constructor(message: string) {
super(message);
this.name = "UploadError";
}
}
export class ValidationError extends Error {
readonly _tag = "ValidationError";
constructor(message: string) {
super(message);
this.name = "ValidationError";
}
}
export class DragDropError extends Error {
readonly _tag = "DragDropError";
constructor(message: string) {
super(message);
this.name = "DragDropError";
}
}
export const validateMediaFile = (file: File) =>
Effect.gen(function* () {
const validTypes = [
"image/jpeg",
"image/png",
"image/webp",
"image/gif",
"image/svg+xml",
];
if (!validTypes.includes(file.type)) {
yield* Effect.fail(
new ValidationError(
`Invalid file type: ${file.type}. Allowed: ${validTypes.join(", ")}`
)
);
}
const maxSize = 50 * 1024 * 1024;
if (file.size > maxSize) {
yield* Effect.fail(
new ValidationError(
`File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB. Max: 50MB`
)
);
}
return {
name: file.name,
size: file.size,
type: file.type,
};
});
export const uploadMediaFile = (file: File) =>
Effect.gen(function* () {
yield* validateMediaFile(file);
yield* Effect.log(`Uploading ${file.name}...`);
let attempts = 0;
const maxRetries = 3;
let lastError: Error | null = null;
while (attempts < maxRetries) {
try {
const fileInfo = yield* Effect.promise(
() =>
new Promise<{ url: string; name: string; size: number }>(
(resolve, reject) => {
setTimeout(() => {
if (Math.random() > 0.3 || attempts === maxRetries - 1) {
resolve({
url: `https:
name: file.name,
size: file.size,
});
} else {
reject(new Error("Upload failed, retrying..."));
}
}, 500);
}
)
).pipe(Effect.catchAll((error) => Effect.succeed(error)));
if (fileInfo instanceof Error) {
lastError = fileInfo;
attempts++;
if (attempts < maxRetries) {
yield* Effect.sleep("500 millis");
continue;
} else {
yield* Effect.fail(
new UploadError(
`Failed to upload ${file.name} after ${maxRetries} attempts`
)
);
}
}
return {
id: `media_${Date.now()}`,
url: fileInfo.url,
filename: fileInfo.name,
size: fileInfo.size,
mimeType: file.type,
uploadedAt: Date.now(),
} as MediaFile;
} catch (err) {
attempts++;
if (attempts < maxRetries) {
yield* Effect.sleep("500 millis");
} else {
const message = err instanceof Error ? err.message : "Unknown error";
yield* Effect.fail(new UploadError(`Upload failed: ${message}`));
}
}
}
yield* Effect.fail(new UploadError(`Failed to upload ${file.name}`));
});
export const batchUploadMedia = (files: File[]) =>
Effect.gen(function* () {
if (files.length === 0) {
yield* Effect.fail(new ValidationError("No files selected"));
}
if (files.length > 50) {
yield* Effect.fail(
new ValidationError("Cannot upload more than 50 files at once")
);
}
const results: (MediaFile | Error)[] = [];
for (const file of files) {
const either = yield* Effect.either(uploadMediaFile(file));
if (Either.isLeft(either)) {
results.push(either.left as Error);
} else {
results.push(either.right as MediaFile);
}
}
const successful = results.filter(
(r) => !(r instanceof Error)
) as MediaFile[];
const failed = results.filter((r) => r instanceof Error) as Error[];
return {
successful,
failed,
summary: {
total: results.length,
uploaded: successful.length,
errors: failed.length,
},
};
});
export const validateDragDropAssignment = (
mediaId: string,
targetType: string,
targetId: string
) =>
Effect.gen(function* () {
if (!mediaId) {
yield* Effect.fail(new DragDropError("Media ID is missing"));
}
if (!targetType) {
yield* Effect.fail(new DragDropError("Target type is missing"));
}
if (!targetId) {
yield* Effect.fail(new DragDropError("Target ID is missing"));
}
const validTargetTypes = ["page", "blogPost", "galleryDrawer"];
if (!validTargetTypes.includes(targetType)) {
yield* Effect.fail(
new DragDropError(
`Invalid target type: ${targetType}. Valid: ${validTargetTypes.join(", ")}`
)
);
}
return { mediaId, targetType, targetId };
});
export const assignMediaEffect = (
mediaId: string,
targetType: string,
targetId: string,
targetTitle: string
) =>
pipe(
validateDragDropAssignment(mediaId, targetType, targetId),
Effect.flatMap(() =>
Effect.gen(function* () {
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
);
return { success: true, mediaId, targetType, targetId };
}).pipe(
Effect.catchAll(() =>
Effect.fail(new MediaError("Failed to assign media to content"))
)
)
)
);
export const unassignMediaEffect = (mediaId: string) =>
Effect.gen(function* () {
if (!mediaId) {
yield* Effect.fail(new ValidationError("Media ID is required"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MediaError("Failed to unassign media"))
)
);
return { success: true, mediaId };
});
export const deleteMediaEffect = (mediaId: string) =>
Effect.gen(function* () {
if (!mediaId) {
yield* Effect.fail(new ValidationError("Media ID is required"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 500))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MediaError("Failed to delete media"))
)
);
return { success: true, deleted: mediaId };
});
export const batchDeleteMediaEffect = (mediaIds: string[]) =>
Effect.gen(function* () {
if (mediaIds.length === 0) {
yield* Effect.fail(new ValidationError("No media selected"));
}
yield* Effect.log(`Deleting ${mediaIds.length} media files...`);
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 1000))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MediaError("Batch deletion failed"))
)
);
return {
deleted: mediaIds.length,
timestamp: Date.now(),
};
});
export const generateAltText = (filename: string) =>
Effect.gen(function* () {
if (!filename) {
yield* Effect.fail(new ValidationError("Filename is required"));
}
const altText = filename
.replace(/\.[^/.]+$/, "")
.replace(/[-_]/g, " ")
.replace(/\b\w/g, (l) => l.toUpperCase());
return altText;
});

===== FILE: src/app/admin/effects/messages-effects.ts =====
import { Effect, pipe } from "effect";
export interface ContactMessage {
id: string;
name: string;
email: string;
phone?: string;
message: string;
source: string;
read: boolean;
createdAt: number;
}
export interface MessageFilter {
searchQuery?: string;
read?: boolean;
source?: string;
dateRange?: { start: number; end: number };
}
export class MessageError extends Error {
readonly _tag = "MessageError";
constructor(message: string) {
super(message);
this.name = "MessageError";
}
}
export class MessageValidationError extends Error {
readonly _tag = "MessageValidationError";
constructor(message: string) {
super(message);
this.name = "MessageValidationError";
}
}
export const validateEmail = (email: string) =>
Effect.gen(function* () {
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!email || email.trim().length === 0) {
yield* Effect.fail(new MessageValidationError("Email is required"));
}
if (!emailRegex.test(email)) {
yield* Effect.fail(new MessageValidationError(`Invalid email: ${email}`));
}
return email;
});
export const validatePhone = (phone?: string) =>
Effect.gen(function* () {
if (!phone) return undefined;
const phoneRegex = /^[\d\s\-\+\(\)]+$/;
if (!phoneRegex.test(phone)) {
yield* Effect.fail(
new MessageValidationError(`Invalid phone number: ${phone}`)
);
}
return phone;
});
export const filterMessagesEffect = (
messages: ContactMessage[],
filter: MessageFilter
) =>
Effect.gen(function* () {
let filtered = [...messages];
if (filter.searchQuery) {
const query = filter.searchQuery.toLowerCase();
filtered = filtered.filter(
(m) =>
m.name.toLowerCase().includes(query) ||
m.email.toLowerCase().includes(query) ||
m.message.toLowerCase().includes(query)
);
}
if (filter.read !== undefined) {
filtered = filtered.filter((m) => m.read === filter.read);
}
if (filter.source) {
filtered = filtered.filter((m) => m.source === filter.source);
}
if (filter.dateRange) {
filtered = filtered.filter(
(m) =>
m.createdAt >= filter.dateRange!.start &&
m.createdAt <= filter.dateRange!.end
);
}
return filtered;
});
export const markMessageReadEffect = (messageId: string) =>
Effect.gen(function* () {
if (!messageId) {
yield* Effect.fail(new MessageValidationError("Message ID is required"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 200))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MessageError("Failed to mark message as read"))
)
);
return { success: true, messageId };
});
export const bulkMarkReadEffect = (messageIds: string[]) =>
Effect.gen(function* () {
if (messageIds.length === 0) {
yield* Effect.fail(new MessageValidationError("No messages selected"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 500))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MessageError("Bulk operation failed"))
)
);
return { success: true, updated: messageIds.length };
});
export const deleteMessageEffect = (messageId: string) =>
Effect.gen(function* () {
if (!messageId) {
yield* Effect.fail(new MessageValidationError("Message ID is required"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MessageError("Failed to delete message"))
)
);
return { success: true, deleted: messageId };
});
export const sendReplyEffect = (
toEmail: string,
subject: string,
body: string
) =>
pipe(
validateEmail(toEmail),
Effect.flatMap(() =>
Effect.gen(function* () {
if (!subject || subject.trim().length === 0) {
yield* Effect.fail(new MessageValidationError("Subject is required"));
}
if (!body || body.trim().length === 0) {
yield* Effect.fail(
new MessageValidationError("Message body is required")
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 1000))
).pipe(
Effect.catchAll(() =>
Effect.fail(new MessageError("Failed to send reply"))
)
);
return { success: true, sentTo: toEmail };
})
)
);
export const exportMessagesEffect = (messages: ContactMessage[]) =>
Effect.gen(function* () {
if (messages.length === 0) {
yield* Effect.fail(new MessageValidationError("No messages to export"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 800))
).pipe(
Effect.catchAll(() => Effect.fail(new MessageError("Export failed")))
);
const filename = `messages_${new Date().toISOString()}.json`;
return {
filename,
count: messages.length,
size: (JSON.stringify(messages).length / 1024).toFixed(2) + " KB",
};
});

===== FILE: src/app/admin/effects/pages-effects.ts =====
import { Effect, pipe } from "effect";
export interface PageNavItem {
id: string;
label: string;
href?: string;
isExternal?: boolean;
order: number;
parentId?: string;
children?: PageNavItem[];
}
export class PageError extends Error {
readonly _tag = "PageError";
constructor(message: string) {
super(message);
this.name = "PageError";
}
}
export class PageValidationError extends Error {
readonly _tag = "PageValidationError";
constructor(message: string) {
super(message);
this.name = "PageValidationError";
}
}
export class MenuStructureError extends Error {
readonly _tag = "MenuStructureError";
constructor(message: string) {
super(message);
this.name = "MenuStructureError";
}
}
export const validatePageItem = (item: Partial<PageNavItem>) =>
Effect.gen(function* () {
const label = item.label ?? "";
if (!label || label.trim().length === 0) {
yield* Effect.fail(new PageValidationError("Label is required"));
}
if (label.length > 100) {
yield* Effect.fail(
new PageValidationError("Label must be less than 100 characters")
);
}
if (item.href && item.href.trim().length === 0) {
yield* Effect.fail(new PageValidationError("URL cannot be empty"));
}
if (
item.href &&
!item.href.startsWith("/") &&
!item.href.startsWith("http")
) {
yield* Effect.fail(
new PageValidationError("URL must start with / or http")
);
}
return item as PageNavItem;
});
export const validateMenuStructure = (items: PageNavItem[]) =>
Effect.gen(function* () {
const visited = new Set<string>();
const recursionStack = new Set<string>();
const checkForCycles = (itemId?: string): boolean => {
if (!itemId) return true;
if (recursionStack.has(itemId)) return false;
if (visited.has(itemId)) return true;
recursionStack.add(itemId);
const item = items.find((i) => i.id === itemId);
if (item?.children) {
for (const child of item.children) {
if (!checkForCycles(child.id)) return false;
}
}
recursionStack.delete(itemId);
visited.add(itemId);
return true;
};
for (const item of items) {
if (!checkForCycles(item.id)) {
yield* Effect.fail(
new MenuStructureError(
"Circular reference detected in menu structure"
)
);
}
}
return true;
});
export const addPageToMenuEffect = (
item: Partial<PageNavItem>,
existingItems: PageNavItem[]
) =>
pipe(
validatePageItem(item),
Effect.flatMap(() =>
validateMenuStructure([...existingItems, item as PageNavItem])
),
Effect.flatMap(() =>
Effect.gen(function* () {
return {
...item,
id: `page_${Date.now()}`,
order: existingItems.length,
createdAt: Date.now(),
};
}).pipe(
Effect.catchAll(() =>
Effect.fail(new PageError("Failed to add page to menu"))
)
)
)
);
export const reorderMenuEffect = (
items: Array<{ id: string; order: number; parentId?: string }>
) =>
Effect.gen(function* () {
if (items.length === 0) {
yield* Effect.fail(new PageValidationError("No items to reorder"));
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 400))
).pipe(
Effect.catchAll(() =>
Effect.fail(new PageError("Failed to reorder menu"))
)
);
return { success: true, reordered: items.length };
});
export const deletePageFromMenuEffect = (
itemId: string,
hasChildren: boolean
) =>
Effect.gen(function* () {
if (!itemId) {
yield* Effect.fail(new PageValidationError("Item ID is required"));
}
if (hasChildren) {
yield* Effect.fail(
new MenuStructureError(
"Cannot delete item with children. Please delete children first."
)
);
}
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
).pipe(
Effect.catchAll(() => Effect.fail(new PageError("Failed to delete page")))
);
return { success: true, deleted: itemId };
});
export const flattenMenuEffect = (items: PageNavItem[]) =>
Effect.gen(function* () {
const flattened: PageNavItem[] = [];
const flatten = (item: PageNavItem, level = 0) => {
flattened.push({ ...item });
if (item.children) {
for (const child of item.children) {
flatten(child, level + 1);
}
}
};
for (const item of items) {
flatten(item);
}
return flattened;
});

===== FILE: src/app/admin/effects/seo-effects.ts =====
import { Effect, pipe } from "effect";
export interface SEOData {
path: string;
title: string;
description: string;
canonicalUrl?: string;
}
export interface SEOValidation {
isValid: boolean;
score: number;
issues: string[];
suggestions: string[];
}
export class SEOError extends Error {
readonly _tag = "SEOError";
constructor(message: string) {
super(message);
this.name = "SEOError";
}
}
export class SEOValidationError extends Error {
readonly _tag = "SEOValidationError";
constructor(message: string) {
super(message);
this.name = "SEOValidationError";
}
}
export const validateTitle = (title: string) =>
Effect.gen(function* () {
const MIN = 30;
const MAX = 60;
const OPTIMAL_MIN = 50;
const OPTIMAL_MAX = 60;
if (!title || title.trim().length === 0) {
yield* Effect.fail(new SEOValidationError("Title is required"));
}
if (title.length < MIN) {
yield* Effect.fail(
new SEOValidationError(
`Title is too short (${title.length}/${MIN} characters minimum)`
)
);
}
if (title.length > MAX) {
yield* Effect.fail(
new SEOValidationError(
`Title is too long (${title.length}/${MAX} characters maximum)`
)
);
}
return {
valid: true,
length: title.length,
inOptimalRange:
title.length >= OPTIMAL_MIN && title.length <= OPTIMAL_MAX,
};
});
export const validateDescription = (description: string) =>
Effect.gen(function* () {
const MIN = 120;
const MAX = 160;
const OPTIMAL_MIN = 150;
const OPTIMAL_MAX = 160;
if (!description || description.trim().length === 0) {
yield* Effect.fail(new SEOValidationError("Description is required"));
}
if (description.length < MIN) {
yield* Effect.fail(
new SEOValidationError(
`Description is too short (${description.length}/${MIN} characters minimum)`
)
);
}
if (description.length > MAX) {
yield* Effect.fail(
new SEOValidationError(
`Description is too long (${description.length}/${MAX} characters maximum - will be truncated)`
)
);
}
return {
valid: true,
length: description.length,
inOptimalRange:
description.length >= OPTIMAL_MIN && description.length <= OPTIMAL_MAX,
};
});
export const validateSEO = (seo: Partial<SEOData>) =>
pipe(
Effect.all([
validateTitle(seo.title || ""),
validateDescription(seo.description || ""),
]),
Effect.flatMap(() =>
Effect.gen(function* () {
if (!seo.path) {
yield* Effect.fail(new SEOValidationError("Page path is required"));
}
if (seo.canonicalUrl) {
try {
new URL(seo.canonicalUrl);
} catch {
yield* Effect.fail(
new SEOValidationError(
`Invalid canonical URL: ${seo.canonicalUrl}`
)
);
}
}
return seo as SEOData;
})
)
);
export const calculateSEOScore = (seo: SEOData) =>
Effect.gen(function* () {
let score = 0;
if (seo.title.length >= 30 && seo.title.length <= 60) {
score += 25;
} else if (seo.title.length >= 50 && seo.title.length <= 60) {
score += 25;
}
if (seo.description.length >= 120 && seo.description.length <= 160) {
score += 25;
} else if (seo.description.length >= 150 && seo.description.length <= 160) {
score += 25;
}
if (
seo.title.toLowerCase().includes(seo.path) ||
seo.description.toLowerCase().includes(seo.path)
) {
score += 20;
}
if (seo.canonicalUrl) {
score += 15;
}
if (seo.title.split(" ").length > 3) {
score += 15;
}
return Math.min(score, 100);
});
export const generateSEOSuggestions = (seo: SEOData) =>
Effect.gen(function* () {
const suggestions: string[] = [];
if (seo.title.length < 50) {
suggestions.push("Consider expanding your title to 50-60 characters");
}
if (seo.description.length < 150) {
suggestions.push(
"Make your description longer (aim for 150-160 characters)"
);
}
if (!seo.title.toLowerCase().includes("keyword")) {
suggestions.push("Include primary keywords in your title");
}
if (seo.title.split(" ").length < 4) {
suggestions.push("Use more descriptive words in your title");
}
if (!seo.canonicalUrl) {
suggestions.push(
"Add a canonical URL to prevent duplicate content issues"
);
}
return suggestions;
});
export const updateSEOEffect = (seo: Partial<SEOData>) =>
pipe(
validateSEO(seo),
Effect.flatMap((validSEO) =>
Effect.gen(function* () {
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 300))
);
return validSEO;
}).pipe(
Effect.catchAll(() =>
Effect.fail(new SEOError("Failed to update SEO data"))
)
)
),
Effect.tap(() => Effect.log("SEO data updated successfully"))
);
export const bulkUpdateSEOEffect = (pages: Partial<SEOData>[]) =>
Effect.gen(function* () {
if (pages.length === 0) {
yield* Effect.fail(new SEOValidationError("No pages to update"));
}
const validationResults = yield* Effect.all(
pages.map((page) => validateSEO(page))
);
yield* Effect.promise(
() => new Promise((resolve) => setTimeout(resolve, 1000))
).pipe(
Effect.catchAll(() => Effect.fail(new SEOError("Bulk update failed")))
);
return {
updated: validationResults.length,
timestamp: Date.now(),
};
});

===== FILE: src/app/admin/effects/settings-effects.ts =====
import { v } from "convex/values";
import { query, mutation } from "./_generated/server";
export const getProfile = query({
args: {},
handler: async (ctx) => {
const profile = await ctx.db.query("siteSettings").first();
return profile;
},
});
export const updateProfile = mutation({
args: {
name: v.string(),
bio: v.string(),
avatar: v.optional(v.string()),
email: v.optional(v.string()),
location: v.optional(v.string()),
socialLinks: v.optional(
v.object({
github: v.optional(v.string()),
linkedin: v.optional(v.string()),
twitter: v.optional(v.string()),
codepen: v.optional(v.string()),
youtube: v.optional(v.string()),
})
),
},
handler: async (ctx, args) => {
const existing = await ctx.db.query("siteSettings").first();
if (existing) {
await ctx.db.patch(existing._id, {
...args,
updatedAt: Date.now(),
});
return existing._id;
} else {
return await ctx.db.insert("siteSettings", {
...args,
updatedAt: Date.now(),
});
}
},
});
export const updateAvatar = mutation({
args: {
avatar: v.string(),
},
handler: async (ctx, args) => {
const existing = await ctx.db.query("siteSettings").first();
if (existing) {
await ctx.db.patch(existing._id, {
avatar: args.avatar,
updatedAt: Date.now(),
});
return existing._id;
} else {
return await ctx.db.insert("siteSettings", {
name: "",
bio: "",
avatar: args.avatar,
updatedAt: Date.now(),
});
}
},
});
export const removeAvatar = mutation({
args: {},
handler: async (ctx) => {
const existing = await ctx.db.query("siteSettings").first();
if (existing) {
await ctx.db.patch(existing._id, {
avatar: undefined,
updatedAt: Date.now(),
});
}
},
});
export const seedProfile = mutation({
args: {},
handler: async (ctx) => {
const existing = await ctx.db.query("siteSettings").first();
if (existing) {
return { success: true, message: "Profile already exists" };
}
await ctx.db.insert("siteSettings", {
name: "Chris Lane Jones",
bio: "Full-stack developer specializing in Next.js, React, and WordPress. Building modern web applications for businesses and government agencies from Virginia.",
email: "",
location: "Louisa, Virginia",
socialLinks: {
github: "https:
linkedin: "https:
twitter: "https:
codepen: "https:
},
updatedAt: Date.now(),
});
return { success: true, message: "Profile seeded successfully" };
},
});

===== FILE: src/app/admin/hooks/useBlogMutation.ts =====
"use client";
import { useState, useCallback } from "react";
import type { BlogPostData } from "../effects/blog-effects";
export const useBlogMutation = () => {
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const createPost = useCallback(async (post: BlogPostData) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 500));
return { success: true, data: post };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
}, []);
const updatePost = useCallback(
async (postId: string, post: Partial<BlogPostData>) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 500));
return { success: true, data: post };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
},
[]
);
return {
createPost,
updatePost,
isLoading,
error,
};
};

===== FILE: src/app/admin/hooks/useCareerEffect.ts =====
"use client";
import { useState, useCallback } from "react";
import type { CareerEvent } from "../effects/career-effects";
export const useCareerEffect = () => {
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const createEvent = useCallback(async (event: Partial<CareerEvent>) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 400));
return { success: true, data: event };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
}, []);
return {
createEvent,
isLoading,
error,
};
};

===== FILE: src/app/admin/hooks/useEngagementEffect.ts =====
"use client";
import { useState, useCallback } from "react";
export const useEngagementEffect = () => {
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const approveComment = useCallback(async (commentId: string) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 200));
return { success: true };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
}, []);
const rejectComment = useCallback(async (commentId: string) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 200));
return { success: true };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
}, []);
return {
approveComment,
rejectComment,
isLoading,
error,
};
};

===== FILE: src/app/admin/hooks/useLinksEffect.ts =====
"use client";
import { useState, useCallback } from "react";
import { Effect } from "effect";
import type {
BrowserLink,
LinkValidationResult,
} from "../effects/links-effects";
import {
validateLink,
extractDomain,
createLinkEffect,
toggleFeaturedEffect,
deleteCategoryEffect,
filterLinksByCategoryEffect,
getFeaturedLinksEffect,
sortLinksEffect,
} from "../effects/links-effects";
export const useLinksEffect = () => {
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const [validationResult, setValidationResult] =
useState<LinkValidationResult | null>(null);
const validateAndCreateLink = useCallback(
async (linkData: Partial<BrowserLink>) => {
setIsLoading(true);
setError(null);
setValidationResult(null);
try {
const result = await Effect.runPromise(createLinkEffect(linkData));
return { success: true, data: result };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
},
[]
);
const validateLinkData = useCallback(
async (linkData: Partial<BrowserLink>) => {
setIsLoading(true);
setError(null);
try {
const result = await Effect.runPromise(validateLink(linkData));
setValidationResult(result);
return result;
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
setValidationResult({
isValid: false,
errors: [error.message],
warnings: [],
});
return null;
} finally {
setIsLoading(false);
}
},
[]
);
const getDomainFromUrl = useCallback(async (url: string) => {
try {
const domain = await Effect.runPromise(extractDomain(url));
return domain;
} catch (err) {
return null;
}
}, []);
const toggleLinkFeatured = useCallback(async (link: BrowserLink) => {
setIsLoading(true);
setError(null);
try {
const result = await Effect.runPromise(toggleFeaturedEffect(link));
return { success: true, data: result };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
}, []);
const deleteCategoryWithLinks = useCallback(
async (category: string, linkCount: number) => {
setIsLoading(true);
setError(null);
try {
const result = await Effect.runPromise(
deleteCategoryEffect(category, linkCount)
);
return { success: true, data: result };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
},
[]
);
const filterByCategory = useCallback(
async (links: BrowserLink[], category: string) => {
try {
return await Effect.runPromise(
filterLinksByCategoryEffect(links, category)
);
} catch {
return links;
}
},
[]
);
const getFeaturedLinks = useCallback(async (links: BrowserLink[]) => {
try {
return await Effect.runPromise(getFeaturedLinksEffect(links));
} catch {
return [];
}
}, []);
const sortLinks = useCallback(async (links: BrowserLink[]) => {
try {
return await Effect.runPromise(sortLinksEffect(links));
} catch {
return links;
}
}, []);
const clearError = useCallback(() => {
setError(null);
}, []);
const clearValidation = useCallback(() => {
setValidationResult(null);
}, []);
return {
validateAndCreateLink,
validateLinkData,
getDomainFromUrl,
toggleLinkFeatured,
deleteCategoryWithLinks,
filterByCategory,
getFeaturedLinks,
sortLinks,
clearError,
clearValidation,
isLoading,
error,
validationResult,
};
};

===== FILE: src/app/admin/hooks/useSeoEffect.ts =====
"use client";
import { useState, useCallback } from "react";
import type { SEOData } from "../effects/seo-effects";
export const useSeoEffect = () => {
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<Error | null>(null);
const [seoScore, setSeoScore] = useState(0);
const validateAndUpdateSEO = useCallback(
async (seoData: Partial<SEOData>) => {
setIsLoading(true);
setError(null);
try {
await new Promise((resolve) => setTimeout(resolve, 500));
let score = 0;
if (seoData.title?.length ?? 0 >= 50) score += 25;
if (seoData.description?.length ?? 0 >= 150) score += 25;
if (seoData.canonicalUrl) score += 20;
score += 30;
setSeoScore(Math.min(score, 100));
return { success: true, data: seoData };
} catch (err) {
const error = err instanceof Error ? err : new Error(String(err));
setError(error);
throw error;
} finally {
setIsLoading(false);
}
},
[]
);
return {
validateAndUpdateSEO,
isLoading,
error,
seoScore,
};
};

===== FILE: src/app/admin/hooks/useToast.ts =====
"use client";
import { useState, useCallback } from "react";
export type ToastType = "success" | "error" | "info" | "loading";
export interface Toast {
id: string;
message: string;
type: ToastType;
duration?: number;
}
export const useToast = () => {
const [toasts, setToasts] = useState<Toast[]>([]);
const addToast = useCallback(
(message: string, type: ToastType = "info", duration: number = 4000) => {
const id = `toast-${Date.now()}-${Math.random().toString(36).slice(2)}`;
const toast: Toast = { id, message, type, duration };
setToasts((prev) => [...prev, toast]);
if (type !== "loading" && duration > 0) {
setTimeout(() => {
setToasts((prev) => prev.filter((t) => t.id !== id));
}, duration);
}
return id;
},
[]
);
const removeToast = useCallback((id: string) => {
setToasts((prev) => prev.filter((t) => t.id !== id));
}, []);
const success = useCallback(
(message: string, duration?: number) =>
addToast(message, "success", duration),
[addToast]
);
const error = useCallback(
(message: string, duration?: number) =>
addToast(message, "error", duration),
[addToast]
);
const info = useCallback(
(message: string, duration?: number) => addToast(message, "info", duration),
[addToast]
);
const loading = useCallback(
(message: string) => addToast(message, "loading", 0),
[addToast]
);
const withToast = useCallback(
async <T>(
mutation: () => Promise<T>,
options: {
loading?: string;
success?: string;
error?: string;
} = {}
): Promise<T | null> => {
const loadingId = options.loading ? loading(options.loading) : null;
try {
const result = await mutation();
if (loadingId) removeToast(loadingId);
if (options.success) success(options.success);
return result;
} catch (err) {
if (loadingId) removeToast(loadingId);
const errorMessage =
options.error ||
(err instanceof Error ? err.message : "Something went wrong");
error(errorMessage);
return null;
}
},
[loading, success, error, removeToast]
);
return {
toasts,
addToast,
removeToast,
success,
error,
info,
loading,
withToast,
};
};

===== FILE: src/app/admin/layout.tsx =====
export const metadata = {
title: "Admin Dashboard | Chris Lane Jones",
description: "Manage portfolio content and SEO",
};
export default function AdminLayout({
children,
}: {
children: React.ReactNode;
}) {
return (
<div className="fixed inset-0 overflow-hidden bg-base text-ink">
{children}
</div>
);
}

===== FILE: src/app/admin/page.tsx =====
import { Suspense } from "react";
import AdminDashboard from "./AdminDashboard/AdminDashboard";
export default function AdminPage() {
return (
<Suspense
fallback={
<div className="flex items-center justify-center min-h-screen bg-base">
<div className="flex flex-col items-center gap-4">
<div className="w-8 h-8 border-4 border-accent border-t-transparent rounded-full animate-spin" />
<p className="text-muted">Loading admin dashboardâ€¦</p>
</div>
</div>
}
>
<AdminDashboard />
</Suspense>
);
}

===== FILE: src/app/api/uploadthing/core.ts =====
import { createUploadthing, type FileRouter } from "uploadthing/next";
const f = createUploadthing();
export const ourFileRouter = {
mediaUploader: f({ image: { maxFileSize: "8MB", maxFileCount: 10 } })
.middleware(async () => {
return { uploadedBy: "admin" };
})
.onUploadComplete(async ({ metadata, file }) => {
console.log("Upload complete for:", metadata.uploadedBy);
console.log("File URL:", file.url);
console.log("File name:", file.name);
console.log("File size:", file.size);
return {
uploadedBy: metadata.uploadedBy,
url: file.url,
filename: file.name,
size: file.size,
};
}),
blogImageUploader: f({ image: { maxFileSize: "4MB", maxFileCount: 1 } })
.middleware(async () => {
return { uploadedBy: "admin" };
})
.onUploadComplete(async ({ metadata, file }) => {
console.log("Upload complete for:", metadata.uploadedBy);
console.log("File URL:", file.url);
return { uploadedBy: metadata.uploadedBy, url: file.url };
}),
} satisfies FileRouter;
export type OurFileRouter = typeof ourFileRouter;

===== FILE: src/app/api/uploadthing/route.ts =====
import { createRouteHandler } from "uploadthing/next";
import { ourFileRouter } from "./core";
export const { GET, POST } = createRouteHandler({
router: ourFileRouter,
});

===== FILE: src/app/blog/BlogPage.tsx =====
"use client";
import { Card } from "@/components/page/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { useQuery } from "convex/react";
import { api } from "../../../convex/_generated/api";
import Link from "next/link";
import { Calendar, Heart, ArrowRight } from "lucide-react";
import Image from "next/image";
const getBadgeVariant = (index: number) => {
const variants = [
"blue",
"green",
"purple",
"orange",
"pink",
"cyan",
"yellow",
"red",
] as const;
return variants[index % variants.length];
};
export default function BlogPage() {
const posts = useQuery(api.blogPosts.getAllPosts);
if (!posts) {
return (
<div className="site-container py-12">
<div className="flex justify-center items-center py-12">
<div className="w-8 h-8 border-4 border-accent border-t-transparent rounded-full animate-spin"></div>
</div>
</div>
);
}
return (
<div className="site-container py-12">
{posts.length === 0 ? (
<Card size="full" className="text-center">
<p className="p text-ink">No blog posts yet. Check back soon!</p>
</Card>
) : (
<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
{posts.map((post, index) => (
<Card
size="small"
delay={0.1 + index * 0.05}
className="overflow-hidden flex flex-col"
>
{post.coverImage && (
<Link href={`/blog/${post.slug}`} className="block">
<div className="relative w-full aspect-[16/9] bg-white/5">
<Image
src={post.coverImage}
alt={post.title}
fill
sizes="(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw"
className="object-cover"
/>
</div>
</Link>
)}
<div className="flex-1 p-6 flex flex-col">
<Link
href={`/blog/${post.slug}`}
className="nav-link inline-block mb-2"
>
<h3 className="text-ink tracking-tight line-clamp-2">
{post.title}
</h3>
</Link>
<div className="flex items-center gap-4 text-ink mb-3">
<div className="flex items-center gap-1">
<Calendar className="w-3 h-3" />
<time dateTime={new Date(post.createdAt).toISOString()}>
{new Date(post.createdAt).toLocaleDateString("en-US", {
year: "numeric",
month: "long",
day: "numeric",
})}
</time>
</div>
<div className="flex items-center gap-1">
<Heart className="w-3 h-3" />
<span>{post.likesCount || 0}</span>
</div>
</div>
<p className="text-ink mb-4 line-clamp-3 flex-1">
{post.excerpt}
</p>
{post.tags && post.tags.length > 0 && (
<div className="flex flex-wrap gap-2 mb-4">
{post.tags.slice(0, 3).map((tag, index) => (
<Badge key={tag} variant={getBadgeVariant(index)}>
{tag}
</Badge>
))}
</div>
)}
<div className="mt-auto">
<Button
asChild
variant="neutral"
size="sm"
className="w-full"
>
<Link href={`/blog/${post.slug}`}>
Read More
<ArrowRight className="w-4 h-4 ml-2" />
</Link>
</Button>
</div>
</div>
</Card>
))}
</div>
)}
</div>
);
}

===== FILE: src/app/blog/page.tsx =====
import Header from "@/components/layout/Header";
import Footer from "@/components/layout/Footer";
import Banner from "@/components/page/banner";
import BlogPage from "./BlogPage";
import { getPageSEO } from "@/lib/seo";
import { getPageHeader } from "@/data/header-data";
export async function generateMetadata() {
return await getPageSEO("/blog");
}
export default function Page() {
const headerData = getPageHeader("/blog");
return (
<>
<Header />
<Banner
title={headerData.title}
breadcrumbPage={headerData.breadcrumbPage}
description={headerData.description}
/>
<main>
<BlogPage />
</main>
<Footer />
</>
);
}

