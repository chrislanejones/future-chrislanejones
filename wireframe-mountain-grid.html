<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wireframe Mountain Grid - Top View</title>
    <style>
        :root {
            --color-base: #f9fafb;
            --color-panel: #ffffff;
            --color-ink: #111827;
            --color-foreground: #374151;
            --color-muted: #6b7280;
            --color-muted-accent: rgba(107, 114, 128, 0.08);
            --color-surface-hover: #f3f4f6;
            --color-accent: #22c55e;
            --color-accent-alt: #3b82f6;
            --color-on-accent: #ffffff;
            --color-border: #e5e7eb;
            --radius: 12px;
            --focus-ring: 2px solid var(--color-accent-alt);
            --step--1: clamp(0.82rem, 0.8rem + 0.18vw, 0.95rem);
            --step-0: clamp(0.95rem, 0.88rem + 0.25vw, 1.05rem);
            --step-1: clamp(1.1rem, 1rem + 0.35vw, 1.25rem);
            --step-2: clamp(1.25rem, 1.1rem + 0.55vw, 1.45rem);
            --step-3: clamp(1.45rem, 1.2rem + 1vw, 1.75rem);
            --step-4: clamp(2rem, 1.45rem + 2.3vw, 2.5rem);
            --weight-regular: 400;
            --weight-demibold: 600;
            --weight-bold: 700;
            --weight-black: 900;
            --sidebar: #ffffff;
            --sidebar-foreground: #111827;
            --sidebar-primary: #374151;
            --sidebar-primary-foreground: #ffffff;
            --sidebar-accent: #f3f4f6;
            --sidebar-accent-foreground: #374151;
            --sidebar-border: #e5e7eb;
            --sidebar-ring: #9ca3af;
        }

        .dark {
            --color-base: #0b0d10;
            --color-panel: #111418;
            --color-ink: #f3f4f6;
            --color-foreground: #d1d5db;
            --color-muted: #9ca3af;
            --color-muted-accent: rgba(255, 255, 255, 0.05);
            --color-surface-hover: #1a1e24;
            --color-accent: #4ade80;
            --color-accent-alt: #60a5fa;
            --color-on-accent: #0b0d10;
            --color-border: #1f242b;
            --sidebar: #111418;
            --sidebar-foreground: #f3f4f6;
            --sidebar-primary: #4ade80;
            --sidebar-primary-foreground: #0b0d10;
            --sidebar-accent: #1a1e24;
            --sidebar-accent-foreground: #f3f4f6;
            --sidebar-border: #1f242b;
            --sidebar-ring: #6b7280;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--color-base);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            transition: background 0.3s ease;
        }

        .container {
            text-align: center;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        h1 {
            color: var(--color-ink);
            font-size: var(--step-4);
            font-weight: var(--weight-bold);
            transition: color 0.3s ease;
        }

        .theme-toggle {
            background: var(--color-panel);
            border: 1px solid var(--color-border);
            color: var(--color-foreground);
            width: 44px;
            height: 44px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .theme-toggle:hover {
            background: var(--color-surface-hover);
            transform: scale(1.05);
        }

        .theme-toggle:focus {
            outline: var(--focus-ring);
            outline-offset: 2px;
        }

        canvas {
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            background: var(--color-panel);
            transition: border-color 0.3s ease, background 0.3s ease;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: var(--color-accent);
            color: var(--color-on-accent);
            border: none;
            padding: 12px 24px;
            border-radius: var(--radius);
            cursor: pointer;
            font-size: var(--step-0);
            font-weight: var(--weight-demibold);
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            filter: brightness(1.1);
        }

        button:active {
            transform: translateY(0);
        }

        button:focus {
            outline: var(--focus-ring);
            outline-offset: 2px;
        }

        .info {
            color: var(--color-muted);
            margin-top: 15px;
            font-size: var(--step--1);
            transition: color 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèîÔ∏è Wireframe Mountain Grid</h1>
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">
                <span id="theme-icon">üåô</span>
            </button>
        </div>
        <canvas id="canvas" width="800" height="800"></canvas>
        
        <div class="controls">
            <button onclick="generateTerrain()">üóª New Terrain</button>
            <button onclick="generatePeaks()">‚õ∞Ô∏è Multiple Peaks</button>
            <button onclick="generateVolcano()">üåã Volcano</button>
            <button onclick="toggleAnimation()">‚ñ∂Ô∏è Animate</button>
        </div>
        
        <div class="controls">
            <button onclick="decreaseGrid()">‚ûñ Fewer Grid Squares</button>
            <button onclick="increaseGrid()">‚ûï More Grid Squares</button>
        </div>
        
        <div class="info">
            Grid Size: <span id="gridSizeDisplay">50x50</span> | Viewing from directly above with perspective depth
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let gridSize = 50;
        const cellSize = 15;
        let heightMap = [];
        let animating = false;
        let animationFrame = 0;
        let currentTerrainType = 'terrain'; // Track what was last generated

        // Theme handling
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            const icon = document.getElementById('theme-icon');
            icon.textContent = document.documentElement.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
            draw(); // Redraw canvas with new colors
        }

        // Load saved theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            document.documentElement.classList.add('dark');
            document.getElementById('theme-icon').textContent = '‚òÄÔ∏è';
        }

        function getComputedColor(property) {
            return getComputedStyle(document.documentElement).getPropertyValue(property).trim();
        }

        function updateGridSizeDisplay() {
            document.getElementById('gridSizeDisplay').textContent = `${gridSize}x${gridSize}`;
        }

        function increaseGrid() {
            if (gridSize < 100) {
                gridSize += 10;
                updateGridSizeDisplay();
                regenerateCurrentTerrain();
            }
        }

        function decreaseGrid() {
            if (gridSize > 20) {
                gridSize -= 10;
                updateGridSizeDisplay();
                regenerateCurrentTerrain();
            }
        }

        function regenerateCurrentTerrain() {
            switch(currentTerrainType) {
                case 'peaks':
                    generatePeaks();
                    break;
                case 'volcano':
                    generateVolcano();
                    break;
                default:
                    generateTerrain();
            }
        }

        function initHeightMap() {
            heightMap = [];
            for (let y = 0; y < gridSize; y++) {
                heightMap[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    heightMap[y][x] = 0;
                }
            }
        }

        function setHeight(x, y, height) {
            if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
                heightMap[y][x] = Math.max(heightMap[y][x], height);
            }
        }

        function generateTerrain() {
            currentTerrainType = 'terrain';
            initHeightMap();
            
            // Generate random terrain with Perlin-like noise
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let height = 0;
                    
                    // Multiple octaves for natural looking terrain
                    height += Math.sin(x * 0.1) * Math.cos(y * 0.1) * 30;
                    height += Math.sin(x * 0.3) * Math.cos(y * 0.2) * 15;
                    height += Math.sin(x * 0.05) * Math.cos(y * 0.05) * 50;
                    
                    // Add some randomness
                    height += (Math.random() - 0.5) * 20;
                    
                    heightMap[y][x] = Math.max(0, height);
                }
            }
            
            draw();
        }

        function generatePeaks() {
            currentTerrainType = 'peaks';
            initHeightMap();
            
            // Generate 5-8 random peaks
            const numPeaks = 5 + Math.floor(Math.random() * 4);
            
            for (let p = 0; p < numPeaks; p++) {
                const peakX = Math.floor(Math.random() * gridSize);
                const peakY = Math.floor(Math.random() * gridSize);
                const peakHeight = 80 + Math.random() * 60;
                const radius = 8 + Math.random() * 8;
                
                // Create mountain with radial falloff
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        const distance = Math.sqrt(Math.pow(x - peakX, 2) + Math.pow(y - peakY, 2));
                        const height = peakHeight * Math.exp(-distance / radius);
                        setHeight(x, y, height);
                    }
                }
            }
            
            draw();
        }

        function generateVolcano() {
            currentTerrainType = 'volcano';
            initHeightMap();
            
            const centerX = gridSize / 2;
            const centerY = gridSize / 2;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    let height;
                    if (distance < 4) {
                        // Crater - lower center
                        height = 60;
                    } else if (distance < 15) {
                        // Steep slopes
                        height = 60 + (distance - 4) * 8;
                    } else {
                        // Gradual falloff
                        height = Math.max(0, 140 - (distance - 15) * 4);
                    }
                    
                    heightMap[y][x] = height;
                }
            }
            
            draw();
        }

        function draw() {
            const bgColor = getComputedColor('--color-panel');
            const accentColor = getComputedColor('--color-accent');
            
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 0.7;
            
            // Parse accent color for RGB manipulation
            let baseR, baseG, baseB;
            if (accentColor.startsWith('#')) {
                // Handle hex color
                const hex = accentColor.replace('#', '');
                baseR = parseInt(hex.substr(0, 2), 16);
                baseG = parseInt(hex.substr(2, 2), 16);
                baseB = parseInt(hex.substr(4, 2), 16);
            } else {
                // Default to green
                baseR = 34;
                baseG = 197;
                baseB = 94;
            }
            
            ctx.lineWidth = 1;
            
            // Draw horizontal lines (across X axis)
            for (let y = 0; y < gridSize; y++) {
                ctx.beginPath();
                
                for (let x = 0; x < gridSize; x++) {
                    const height = heightMap[y][x];
                    
                    // Project 3D to 2D (top-down with perspective)
                    const screenX = centerX + (x - gridSize/2) * cellSize * scale;
                    const screenY = centerY + (y - gridSize/2) * cellSize * scale - height * scale * 0.8;
                    
                    if (x === 0) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                
                // Gradient based on Y position for depth
                const depthFactor = y / gridSize;
                const brightness = 0.4 + depthFactor * 0.6;
                ctx.strokeStyle = `rgba(${baseR}, ${baseG}, ${baseB}, ${brightness})`;
                ctx.stroke();
            }
            
            // Draw vertical lines (across Y axis)
            for (let x = 0; x < gridSize; x++) {
                ctx.beginPath();
                
                for (let y = 0; y < gridSize; y++) {
                    const height = heightMap[y][x];
                    
                    const screenX = centerX + (x - gridSize/2) * cellSize * scale;
                    const screenY = centerY + (y - gridSize/2) * cellSize * scale - height * scale * 0.8;
                    
                    if (y === 0) {
                        ctx.moveTo(screenX, screenY);
                    } else {
                        ctx.lineTo(screenX, screenY);
                    }
                }
                
                // Gradient based on X position
                const depthFactor = x / gridSize;
                const brightness = 0.4 + depthFactor * 0.6;
                ctx.strokeStyle = `rgba(${baseR}, ${baseG}, ${baseB}, ${brightness})`;
                ctx.stroke();
            }
        }

        function animate() {
            if (!animating) return;
            
            animationFrame += 0.02;
            
            // Animate the terrain
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const baseHeight = heightMap[y][x];
                    const wave = Math.sin(x * 0.2 + animationFrame) * Math.cos(y * 0.2 + animationFrame) * 10;
                    heightMap[y][x] = baseHeight + wave;
                }
            }
            
            draw();
            requestAnimationFrame(animate);
        }

        function toggleAnimation() {
            animating = !animating;
            const button = event.target;
            button.textContent = animating ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Animate';
            
            if (animating) {
                animate();
            }
        }

        // Initialize
        updateGridSizeDisplay();
        generateTerrain();
    </script>
</body>
</html>
